"use client";

import { useState, useRef, useEffect, useCallback, useMemo } from "react";
import { Textarea } from "@/components/ui/textarea";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import Navbar from "./_components/navbar";
import localFont from "next/font/local";

const masque = localFont({
	src: "./_fonts/masque.ttf",
	variable: "--font-masque",
});
const magazine = localFont({
	src: "./_fonts/magazine.ttf",
	variable: "--font-magazine",
});

type NameOrder = "shuffle" | "ascending" | "descending";
type BackgroundChange = { type: "color"; value: string } | { type: "image"; value: string } | { type: "reset" };

export default function Home() {
	const [names, setNames] = useState("Alice\nBob\nCharlie\nDiana\nEve");
	const [spinning, setSpinning] = useState(false);
	const [rotation, setRotation] = useState(0);
	const [winner, setWinner] = useState<string | null>(null);
	const [showDialog, setShowDialog] = useState(false);
	const [nameOrder, setNameOrder] = useState<NameOrder>("shuffle");
	const [timerDuration, setTimerDuration] = useState(3);
	const [backgroundSelection, setBackgroundSelection] =
		useState<BackgroundChange | null>(null);
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const audioBufferRef = useRef<AudioBuffer | null>(null);
	const audioContextRef = useRef<AudioContext | null>(null);
	const lastSegmentRef = useRef<number>(-1);

	// Initialize Web Audio API for better performance on mobile
	useEffect(() => {
		const initAudio = async () => {
			try {
				type ExtendedWindow = typeof window & {
					webkitAudioContext?: typeof AudioContext;
				};
				const audioConstructor =
					window.AudioContext || (window as ExtendedWindow).webkitAudioContext;
				if (!audioConstructor) return;
				const audioContext = new audioConstructor();
				audioContextRef.current = audioContext;

				// Fetch and decode audio
				const response = await fetch("/sounds/spin.mp3");
				const arrayBuffer = await response.arrayBuffer();
				const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
				audioBufferRef.current = audioBuffer;
			} catch (error) {
				console.error("Audio initialization failed:", error);
			}
		};

		initAudio();

		return () => {
			if (audioContextRef.current) {
				audioContextRef.current.close();
			}
		};
	}, []);

	const reorderNames = useCallback((order: NameOrder, source: string) => {
		const parsed = source
			.split("\n")
			.map((name) => name.trim())
			.filter((name) => name !== "");

		if (parsed.length === 0) return "";

		const arranged = [...parsed];
		switch (order) {
			case "ascending":
				arranged.sort((a, b) => a.localeCompare(b));
				break;
			case "descending":
				arranged.sort((a, b) => b.localeCompare(a));
				break;
			case "shuffle":
			default:
				for (let i = arranged.length - 1; i > 0; i -= 1) {
					const j = Math.floor(Math.random() * (i + 1));
					[arranged[i], arranged[j]] = [arranged[j], arranged[i]];
				}
		}

		return arranged.join("\n");
	}, []);

	const handleNamesOrderChange = useCallback(
		(order: NameOrder) => {
			setNameOrder(order);
			setNames((prev) => reorderNames(order, prev));
		},
		[reorderNames]
	);

	const handleTimerChange = useCallback((seconds: number) => {
		setTimerDuration(seconds);
	}, []);

	const handleBackgroundChange = useCallback((change: BackgroundChange) => {
		setBackgroundSelection(change);
	}, []);

	useEffect(() => {
		if (backgroundSelection?.type === "color") {
			document.body.style.background = backgroundSelection.value;
			document.body.style.backgroundImage = "";
			document.body.style.backgroundSize = "";
			document.body.style.backgroundPosition = "";
			document.body.style.backgroundRepeat = "";
		} else if (backgroundSelection?.type === "image") {
			document.body.style.background = "";
			document.body.style.backgroundImage = `url(${backgroundSelection.value})`;
			document.body.style.backgroundSize = "cover";
			document.body.style.backgroundPosition = "center";
			document.body.style.backgroundRepeat = "no-repeat";
		} else {
			document.body.style.background = "";
			document.body.style.backgroundImage = "";
			document.body.style.backgroundSize = "";
			document.body.style.backgroundPosition = "";
			document.body.style.backgroundRepeat = "";
		}
	}, [backgroundSelection]);

	useEffect(() => {
		return () => {
			document.body.style.background = "";
			document.body.style.backgroundImage = "";
			document.body.style.backgroundSize = "";
			document.body.style.backgroundPosition = "";
			document.body.style.backgroundRepeat = "";
		};
	}, []);
	const namesList = useMemo(
		() =>
			names
				.split("\n")
				.filter((name) => name.trim() !== "")
				.map((name) => name.trim()),
		[names]
	);

	const colors = useMemo(
		() => [
			"#FF6B6B",
			"#4ECDC4",
			"#45B7D1",
			"#FFA07A",
			"#98D8C8",
			"#F7DC6F",
			"#BB8FCE",
			"#85C1E2",
			"#F8B88B",
			"#ABEBC6",
		],
		[]
	);

	const drawWheel = useCallback(() => {
		const canvas = canvasRef.current;
		if (!canvas || namesList.length === 0) return;

		const ctx = canvas.getContext("2d", {
			alpha: true,
			desynchronized: true, // Improve performance on mobile
		});
		if (!ctx) return;

		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;
		const radius = Math.min(centerX, centerY) - 7; // reduced padd3000ing for larger wheel from the edges

		ctx.clearRect(0, 0, canvas.width, canvas.height);

		// Scale factor for center elements: 1.7x (70% increase) on md+ screens (768px+)
		const centerScale = canvas.width >= 768 ? 1.7 : 1;

		// Draw wheel segments
		const anglePerSegment = (2 * Math.PI) / namesList.length;

		namesList.forEach((name, index) => {
			const startAngle = index * anglePerSegment + (rotation * Math.PI) / 180;
			const endAngle = startAngle + anglePerSegment;

			// Draw segment
			ctx.beginPath();
			ctx.moveTo(centerX, centerY);
			ctx.arc(centerX, centerY, radius, startAngle, endAngle);
			ctx.closePath();
			ctx.fillStyle = colors[index % colors.length];
			ctx.fill();
			ctx.strokeStyle = "#fff";
			ctx.lineWidth = 3;
			ctx.stroke();

			// Draw text with dynamic font size based on partition size and text length
			ctx.save();
			ctx.translate(centerX, centerY);
			ctx.rotate(startAngle + anglePerSegment / 2);
			ctx.textAlign = "center";
			ctx.fillStyle = "#000";

			// Calculate base font size based on canvas size (responsive)
			const baseFontSize = Math.max(12, Math.round(radius / 20));

			// Scale by partition size with boost for many names (8+)
			const angleDegrees = (anglePerSegment * 180) / Math.PI;
			const minScale = namesList.length >= 8 ? 1.8 : 0.9;
			const partitionScale = Math.min(
				2.5,
				Math.max(minScale, angleDegrees / 30)
			);
			let fontSize = Math.round(baseFontSize * partitionScale);
			ctx.font = `bold ${fontSize}px Arial`;

			// Available text width (from center to near edge, accounting for padding)
			const maxTextWidth = radius * 0.55; // Max width before edge
			let textWidth = ctx.measureText(name).width;

			// If text is too wide, reduce font size proportionally
			if (textWidth > maxTextWidth) {
				const textLengthScale = maxTextWidth / textWidth;
				fontSize = Math.round(fontSize * textLengthScale);
				fontSize = Math.max(8, fontSize); // Minimum 8px
				ctx.font = `bold ${fontSize}px Arial`;
				textWidth = ctx.measureText(name).width;
			}

			// If still too wide after scaling, truncate with "..."
			let displayText = name;
			if (textWidth > maxTextWidth) {
				while (
					displayText.length > 1 &&
					ctx.measureText(displayText + "...").width > maxTextWidth
				) {
					displayText = displayText.slice(0, -1);
				}
				displayText += "...";
			}

			ctx.fillText(displayText, radius * 0.65, fontSize * 0.3);
			ctx.restore();
		});

		// Add 3D gradient effect to wheel edges
		const gradient = ctx.createRadialGradient(
			centerX,
			centerY,
			radius * 0.5,
			centerX,
			centerY,
			radius
		);
		gradient.addColorStop(0, "rgba(255, 255, 255, 0)");
		gradient.addColorStop(0.85, "rgba(255, 255, 255, 0)");
		gradient.addColorStop(0.95, "rgba(0, 0, 0, 0.08)");
		gradient.addColorStop(1, "rgba(0, 0, 0, 0.16)");

		ctx.beginPath();
		ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
		ctx.fillStyle = gradient;
		ctx.fill();

		// Draw arrow at center with subtle dark shadow and white highlight for 3D depth
		// Triangle arrow shape matching the PNG
		ctx.save();
		ctx.translate(centerX + 20.5 * centerScale, centerY);
		ctx.scale(centerScale, centerScale); // Position moved right by half width

		// Draw a subtle dark soft shadow behind the arrow
		ctx.save();
		ctx.fillStyle = "rgba(0,0,0,0.08)";
		ctx.shadowColor = "rgba(0,0,0,0.16)";
		ctx.shadowBlur = 10;
		ctx.beginPath();
		ctx.moveTo(50, 0);
		ctx.lineTo(-25, -40);
		ctx.lineTo(-25, 40);
		ctx.closePath();
		ctx.fill();
		ctx.restore();

		// Main arrow with a small white highlight (existing look)
		ctx.shadowColor = "rgba(255, 255, 255, 0.9)";
		ctx.shadowBlur = 12;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0;
		ctx.fillStyle = "#000000";
		ctx.beginPath();
		ctx.moveTo(50, 0); // tip pointing right
		ctx.lineTo(-25, -40); // top left corner
		ctx.lineTo(-25, 40); // bottom left corner
		ctx.closePath();
		ctx.fill();

		// Add white highlight edge for more 3D depth
		ctx.shadowColor = "transparent";
		ctx.shadowBlur = 0;
		ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(50, 0);
		ctx.lineTo(-25, -40);
		ctx.stroke();

		ctx.restore();

		// Draw center circle with subtle radial shadow to match wheel edge
		ctx.beginPath();
		const circleRadius = 45 * centerScale;
		ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
		ctx.fillStyle = "#000000";
		ctx.fill();
		ctx.strokeStyle = "#FFFFFF";
		ctx.lineWidth = 3 * centerScale;
		ctx.stroke();

		// Subtle radial shadow overlay for the center circle
		const centerGrad = ctx.createRadialGradient(
			centerX,
			centerY,
			15 * centerScale,
			centerX,
			centerY,
			55 * centerScale
		);
		centerGrad.addColorStop(0, "rgba(0,0,0,0)");
		centerGrad.addColorStop(1, "rgba(0,0,0,0.16)");
		ctx.beginPath();
		ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
		ctx.fillStyle = centerGrad;
		ctx.fill();

		// Add "Spin" text in center
		ctx.fillStyle = "#FFFFFF";
		ctx.font = `bold ${20 * centerScale}px masque`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		// ctx.fillText("Click", centerX, centerY - 18);
		// ctx.font = "bold 14px Arial";
		// ctx.fillText("To", centerX, centerY);
		// ctx.font = "bold 20px Arial";
		// ctx.fillText("Spin", centerX, centerY + 18);
		ctx.fillText("SPIN", centerX, centerY);
	}, [namesList, rotation, colors]);

	useEffect(() => {
		drawWheel();
	}, [drawWheel]);

	const determineWinner = useCallback(
		(finalRotation: number) => {
			if (namesList.length === 0) return;

			const anglePerSegment = 360 / namesList.length;

			// The arrow points to the right (0 degrees / 360 degrees)
			// We need to find which segment is at the right after rotation
			const adjustedRotation = (360 - (finalRotation % 360)) % 360;
			const winnerIndex =
				Math.floor(adjustedRotation / anglePerSegment) % namesList.length;

			setWinner(namesList[winnerIndex]);
			setShowDialog(true);
		},
		[namesList]
	);

	const spinWheel = useCallback(() => {
		if (spinning || namesList.length === 0) return;

		setSpinning(true);

		const duration = Math.max(500, timerDuration * 1000);

		// Random final rotation (multiple full spins + random position)
		const spins = 5 + Math.floor(Math.random() * 5); // 5-10 full spins
		const randomDegree = Math.random() * 360;
		const totalRotation = spins * 360 + randomDegree;

		const startTime = Date.now();
		const startRotation = rotation;

		const animate = () => {
			const elapsed = Date.now() - startTime;
			const progress = Math.min(elapsed / duration, 1);

			// Easing function for smooth deceleration
			const easeOut = 1 - Math.pow(1 - progress, 3);
			const currentRotation = startRotation + totalRotation * easeOut;

			setRotation(currentRotation % 360);

			// Detect segment change and play sound
			const anglePerSegment = 360 / namesList.length;
			const adjustedRotation = (360 - (currentRotation % 360)) % 360;
			const currentSegment =
				Math.floor(adjustedRotation / anglePerSegment) % namesList.length;

			if (currentSegment !== lastSegmentRef.current) {
				lastSegmentRef.current = currentSegment;
				// Play tick sound using Web Audio API (non-blocking)
				const audioBuffer = audioBufferRef.current;
				const audioContext = audioContextRef.current;
				if (audioBuffer && audioContext) {
					// Create a new source node for each tick (they're one-time use)
					const source = audioContext.createBufferSource();
					source.buffer = audioBuffer;
					source.connect(audioContext.destination);
					source.start(0);
				}
			}
			if (progress < 1) {
				requestAnimationFrame(animate);
			} else {
				setSpinning(false);
				lastSegmentRef.current = -1; // Reset for next spin
				determineWinner(currentRotation % 360);
			}
		};

		animate();
	}, [spinning, namesList.length, rotation, determineWinner, timerDuration]);

	// Set canvas size to container width (fill parent)
	useEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		const resizeCanvas = () => {
			const container = canvas.parentElement as HTMLElement | null;
			if (!container) return;

			const size = container.clientWidth; // full width of parent
			canvas.width = size;
			canvas.height = size; // keep square
			canvas.style.width = "100%";
			canvas.style.height = "auto";
			drawWheel();
		};

		resizeCanvas();
		window.addEventListener("resize", resizeCanvas);
		return () => window.removeEventListener("resize", resizeCanvas);
	}, [drawWheel]);

	return (
		<div className="min-h-screen">
			<Navbar
				onNamesOrderChange={handleNamesOrderChange}
				onTimerChange={handleTimerChange}
				onBackgroundChange={handleBackgroundChange}
				currentNameOrder={nameOrder}
				currentTimer={timerDuration}
			/>
			<div className="container mx-auto py-6">
				<main className="flex md:flex-row flex-col gap-1">
					<section id="wheel" className="md:w-[75%]">
						<div className="md:p-8">
							<canvas
								ref={canvasRef}
								className={`cursor-pointer w-full block p-0 ${
spinning ? "pointer-events-none" : ""
}`}
								style={{ padding: 0 }}
								onClick={spinWheel}
							/>
						</div>
						{namesList.length === 0 && (
							<p className="text-center text-gray-500 mt-4">
								Add names to the list to spin the wheel
							</p>
						)}
						{!spinning && namesList.length > 0 && (
							<p className="text-center text-gray-600 mt-4 text-[18px] md:text-[24px] font-bold ">
								Click or Tap the wheel to spin!
							</p>
						)}
						{spinning && (
							<p
								className={`text-center ${masque.className} font-bold text-blue-900 tracking-tight text-[18px] md:text-[24px] mt-4`}
							>
								Spinning . . .
							</p>
						)}
					</section>

					<section id="names-list" className="md:w-[25%] my-2 p-4 font-bold">
						<div className="w-full">
							<label className="block  mb-2 text-gray-600">
								Enter names (one per line)
							</label>
							<Textarea
								value={names}
								onChange={(e) => setNames(e.target.value)}
								placeholder="Enter names, one per line"
								rows={10}
								className="w-full bg-gray-50 text-gray-800 resize-none text-[18px] md:text-[20px] font-bold border-4 shadow-inner
   border-gray-300 focus-visible:ring-0 focus-visible:border-blue-300"
							/>
							<p className="text-sm text-gray-500 mt-2">
								{namesList.length} {namesList.length === 1 ? "name" : "names"}{" "}
								entered
							</p>
						</div>
					</section>
				</main>

				<Dialog open={showDialog} onOpenChange={setShowDialog}>
					<DialogContent
						className={`${magazine.className} flex justify-center py-6  bg-linear-to-r from-yellow-100 via-yellow-200 to-yellow-400`}
					>
						<DialogHeader>
							<DialogTitle
								className={`text-xl tracking-widest py-2 text-yellow-700 font-extralight pb-3`}
							>
								ðŸŽ‰ The winner is... ðŸŽ‰
								{/* ðŸŽ‰ We have the winner! ðŸŽ‰ */}
								{/* ðŸŽ‰ And the winner is... ðŸŽ‰ */}
							</DialogTitle>

							<DialogDescription className="text-4xl tracking-widest text-center text-yellow-900">
								{winner}
							</DialogDescription>
						</DialogHeader>
					</DialogContent>
				</Dialog>
			</div>
		</div>
	);
}
